[[setup]]
== Set up the Agent

:source-highlighter: coderay

[discrete]
[[requirements]]
=== Requirements

This project requires Swift `5.7`, and is intended for use in Swift-base mobile apps.

Other platform requires:

[options="header"]
|===
| platform | version
| `iOS` | `11`
|`macOS` | `10.13`
| `tvOS` | `v11`
| `watchOS` | `3`
|===


[discrete]
[[add-agent-dependency]]
=== Add the Agent dependency
Add the Elastic APM iOS Agent to your Xcode project or your `Package.swift`.

Here are instructions for adding a https://developer.apple.com/documentation/swift_packages/adding_package_dependencies_to_your_app[package dependency] to a standard Xcode poject.

Details of adding dependencies to your Package.swift can be found on https://developer.apple.com/documentation/xcode/creating_a_standalone_swift_package_with_xcode#3578941['Add a Dependency on Another Swift Package'].
Below is a helpful code-snippet:

`package.swift`:
[source,swift,linenums,highlight=2;10]
----
Package(
    dependencies:[
         .package(name: "apm-agent-ios", url: "https://github.com/elastic/apm-agent-ios.git", from: "0.5.0"),
    ],
  targets:[
    .target(
        name: "MyApp",
        dependencies: [
            .product(name: "iOSAgent", package: "apm-agent-ios")
        ]
    ),
])
----

[discrete]
[[initialize]]
=== Initialize the agent
Once the Agent has been added as a dependency, it must be initialized.

If you're using `SwiftUI` to build your app add the following to your `App.swift`:

[source,swift,linenums,swift,highlight=2;7..12]
----
import SwiftUI
import iOSAgent

@main
struct MyApp: App {
    init() {
        var config = AgentConfigBuilder()
                       .withServerUrl(URL(string:"http://127.0.0.1:8200")) <1>
                       .withSecretToken("<SecretToken>") <2>

        Agent.start(with: config)
    }
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}
----
<1> APM Server URL
<2> Set secret token for APM server connection

If you're not using `SwiftUI` you can alternatively add the same thing to your AppDelegate file:

`AppDelegate.swift`
[source,swift,linenums,highlight=2;9..14]
----
import UIKit
import iOSAgent
@main
class AppDelegate: UIResponder, UIApplicationDelegate {
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
var config = AgentConfigBuilder()
                       .withServerUrl(URL(string:"http://127.0.0.1:8200")) <1>
                       .withSecretToken("<SecretToken>") <2>

        Agent.start(with: config)
        return true
    }
}
----
<1> APM Server URL
<2> Set secret token for APM server connection

[discrete]
[[instrumentation-config]]
=== Instrumentation Configuration

An optional parameter for configuring instrumentation is also available on `Agent.start`:
[source,swift]
----
    ...

    let instrumentationConfig = InstrumentationConfigBuilder()
                                         .withCrashReporting(true)
                                         .build()

    Agent.start(with: config, instrumentationConfig)
----
[discrete]
[[config-opts]]
==== Configuration Options

[discrete]
[[with-crash-reporting]]
===== `withCrashReporting(_ enable: Bool) -> Self`
* *Type:* Bool
* *Default:* true

Toggle for crash reporting. Enabled by default. Since only one crash reporter can be set in iOS, this allows for 3rd party crash reporter preference without conflict.

[discrete]
[[with-app-metrics]]
===== `withAppMetricInstrumentation(_ enable: Bool) -> Self`
* *Type:* Bool
* *Default:* true

Toggles AppMetric instrumentation.

[discrete]
[[with-url-session-instrumentation]]
===== `withURLSessionInstrumentation(_ enable: Bool) -> Self`
* *Type:* Bool
* *Default:* true

Toggles network instrumentation.

[discrete]
[[with-view-controller-instrumentation]]
===== `withViewControllerInstrumentation(_ enable: Bool) -> Self`
* *Type:* Bool
* *Default:* true

Toggles view controller instrumentation.

[discrete]
[[with-System-Metrics]]
===== `withSystemMetrics(_ enable: Bool) -> Self`
* *Type:* Bool
* *Default:* true

Toggles metric generation for memory and cpu usage.

[discrete]
[[with-Lifecycle-Events]]
===== `withLifecycleEvents(_ enable: Bool) -> Self`
* *Type:* Bool
* *Default:* true

Toggles event generation for lifecycle events.

[discrete]
[[view-instrumentation]]
=== View instrumentation

The agent provides SwiftUI.View and UIViewController instrumentation, where the load time of a View is measured using spans.
All Views simultaneously loaded will be grouped under the same starting span.
The spans' names will be dictated by the following rules, from least to highest precedence:

1. `<view's class name> - view appearing`
2. `<navigation title> - view appearing`
3. The `name` passed to View extension method  `reportName(_ name: String) -> View`


The View's class name will be a swift name-mangled string, and is the least desirable naming method. If it's possible, set a navigation title on your views:

`AllProductsList.swift`
[source,swift,linenums, highlight=12]
----
struct AllProductsList: View {
    @EnvironmentObject var modelData : ModelData

    var body: some View {
        VStack {
            List(modelData.products, id: \.id) { product in
                AdminProductRow(product: product)

            }
        }.onAppear  {
            modelData.loadProducts()
        }.navigationTitle("All Products")
    }
}
----

You'll see "All Products - view appearing" in Kibana.


If it isn't possible to set a navigation title, use `reportName(_ name: String) -> View` to set the name that will show in Kibana:

`AllProductsList.swift`
[source,swift,linenums, highlight=12]
----
struct AllProductsList: View {
    @EnvironmentObject var modelData : ModelData

    var body: some View {
        VStack {
            List(modelData.products, id: \.id) { product in
                AdminProductRow(product: product)

            }
        }.onAppear  {
            modelData.loadProducts()
        }.reportName("All Products - view appearing")
    }
}
----

NOTE: The entire string `All Products - view appearing` must be inserted to match the default formatting used for the other two naming options.

[discrete]
[[metrickit-instrumentation]]
=== MetricKit Instrumentation
Available for iOS 13 and greater, the agent provides instrumentation of key MetricKit data points:

* Application Launch times
* Application responsiveness
* Application exit counts

Technical details on the metric generated can be found in the https://github.com/elastic/apm/blob/main/specs/agents/mobile/metrics.md#application-metrics[Mobile spec]

[discrete]
[[app-launch-time]]
==== `application.launch.time`
This histogram metric provides launch duration broken down by `first draw`, `first draw (optimized)`, and `resumed`. More details about the MetricKit data point can be found in the https://developer.apple.com/documentation/metrickit/mxapplaunchmetric[Apple documentation].

[discrete]
[[hangtime]]
==== `application.responsiveness.hangtime`
A histogram of the different durations of time in which the app is too busy to handle user interaction responsively.
More details about the MetricKit data point can be found in the https://developer.apple.com/documentation/metrickit/mxappresponsivenessmetric[Apple documentation].

[discrete]
[[exits]]
==== `application.exits`
A count of application exits categorized by various attributes: `foreground` or `background`, and `normal` or abnormal, where abnormal exits are further subdivided.
More details can be found in the https://developer.apple.com/documentation/metrickit/mxappexitmetric[Apple documentation].


[discrete]
[[app-lifecycle-events]]
=== Application Lifecycle Events
In v0.5.0 the application lifecycle events are automatically instrumented.
The technical details can be found in the https://github.com/elastic/apm/blob/main/specs/agents/mobile/events.md#application-lifecycle-events[Mobile spec].