// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: opamp.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2021, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// OpAMP: Open Agent Management Protocol (https://github.com/open-telemetry/opamp-spec)

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Opamp_Proto_AgentToServerFlags: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0

  /// The Agent requests Server go generate a new instance_uid, which will
  /// be sent back in ServerToAgent message
  case requestInstanceUid // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .requestInstanceUid
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .requestInstanceUid: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Opamp_Proto_AgentToServerFlags] = [
    .unspecified,
    .requestInstanceUid,
  ]

}

public enum Opamp_Proto_ServerToAgentFlags: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0

  /// ReportFullState flag can be used by the Server if the Agent did not include the
  /// particular bit of information in the last status report (which is an allowed
  /// optimization) but the Server detects that it does not have it (e.g. was
  /// restarted and lost state). The detection happens using
  /// AgentToServer.sequence_num values.
  /// The Server asks the Agent to report full status.
  case reportFullState // = 1

  /// ReportAvailableComponents flag can be used by the server if the Agent did
  /// not include the full AvailableComponents message, but only the hash.
  /// If this flag is specified, the agent will populate available_components.components
  /// with a full description of the agent's components.
  /// Status: [Development]
  case reportAvailableComponents // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .reportFullState
    case 2: self = .reportAvailableComponents
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .reportFullState: return 1
    case .reportAvailableComponents: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Opamp_Proto_ServerToAgentFlags] = [
    .unspecified,
    .reportFullState,
    .reportAvailableComponents,
  ]

}

public enum Opamp_Proto_ServerCapabilities: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// The capabilities field is unspecified.
  case unspecified // = 0

  /// The Server can accept status reports. This bit MUST be set, since all Server
  /// MUST be able to accept status reports.
  case acceptsStatus // = 1

  /// The Server can offer remote configuration to the Agent.
  case offersRemoteConfig // = 2

  /// The Server can accept EffectiveConfig in AgentToServer.
  case acceptsEffectiveConfig // = 4

  /// The Server can offer Packages.
  /// Status: [Beta]
  case offersPackages // = 8

  /// The Server can accept Packages status.
  /// Status: [Beta]
  case acceptsPackagesStatus // = 16

  /// The Server can offer connection settings.
  /// Status: [Beta]
  case offersConnectionSettings // = 32

  /// The Server can accept ConnectionSettingsRequest and respond with an offer.
  /// Status: [Development]
  case acceptsConnectionSettingsRequest // = 64
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .acceptsStatus
    case 2: self = .offersRemoteConfig
    case 4: self = .acceptsEffectiveConfig
    case 8: self = .offersPackages
    case 16: self = .acceptsPackagesStatus
    case 32: self = .offersConnectionSettings
    case 64: self = .acceptsConnectionSettingsRequest
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .acceptsStatus: return 1
    case .offersRemoteConfig: return 2
    case .acceptsEffectiveConfig: return 4
    case .offersPackages: return 8
    case .acceptsPackagesStatus: return 16
    case .offersConnectionSettings: return 32
    case .acceptsConnectionSettingsRequest: return 64
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Opamp_Proto_ServerCapabilities] = [
    .unspecified,
    .acceptsStatus,
    .offersRemoteConfig,
    .acceptsEffectiveConfig,
    .offersPackages,
    .acceptsPackagesStatus,
    .offersConnectionSettings,
    .acceptsConnectionSettingsRequest,
  ]

}

/// The type of the package, either an addon or a top-level package.
/// Status: [Beta]
public enum Opamp_Proto_PackageType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case topLevel // = 0
  case addon // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .topLevel
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .topLevel
    case 1: self = .addon
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .topLevel: return 0
    case .addon: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Opamp_Proto_PackageType] = [
    .topLevel,
    .addon,
  ]

}

public enum Opamp_Proto_ServerErrorResponseType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// Unknown error. Something went wrong, but it is not known what exactly.
  /// The Agent SHOULD NOT retry the message.
  /// The error_message field may contain a description of the problem.
  case unknown // = 0

  /// The AgentToServer message was malformed. The Agent SHOULD NOT retry
  /// the message.
  case badRequest // = 1

  /// The Server is overloaded and unable to process the request. The Agent
  /// should retry the message later. retry_info field may be optionally
  /// set with additional information about retrying.
  case unavailable // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .badRequest
    case 2: self = .unavailable
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .badRequest: return 1
    case .unavailable: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Opamp_Proto_ServerErrorResponseType] = [
    .unknown,
    .badRequest,
    .unavailable,
  ]

}

/// Status: [Beta]
public enum Opamp_Proto_CommandType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// The Agent should restart. This request will be ignored if the Agent does not
  /// support restart.
  case restart // = 0
  case UNRECOGNIZED(Int)

  public init() {
    self = .restart
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .restart
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .restart: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Opamp_Proto_CommandType] = [
    .restart,
  ]

}

public enum Opamp_Proto_AgentCapabilities: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// The capabilities field is unspecified.
  case unspecified // = 0

  /// The Agent can report status. This bit MUST be set, since all Agents MUST
  /// report status.
  case reportsStatus // = 1

  /// The Agent can accept remote configuration from the Server.
  case acceptsRemoteConfig // = 2

  /// The Agent will report EffectiveConfig in AgentToServer.
  case reportsEffectiveConfig // = 4

  /// The Agent can accept package offers.
  /// Status: [Beta]
  case acceptsPackages // = 8

  /// The Agent can report package status.
  /// Status: [Beta]
  case reportsPackageStatuses // = 16

  /// The Agent can report own trace to the destination specified by
  /// the Server via ConnectionSettingsOffers.own_traces field.
  /// Status: [Beta]
  case reportsOwnTraces // = 32

  /// The Agent can report own metrics to the destination specified by
  /// the Server via ConnectionSettingsOffers.own_metrics field.
  /// Status: [Beta]
  case reportsOwnMetrics // = 64

  /// The Agent can report own logs to the destination specified by
  /// the Server via ConnectionSettingsOffers.own_logs field.
  /// Status: [Beta]
  case reportsOwnLogs // = 128

  /// The can accept connections settings for OpAMP via
  /// ConnectionSettingsOffers.opamp field.
  /// Status: [Beta]
  case acceptsOpAmpconnectionSettings // = 256

  /// The can accept connections settings for other destinations via
  /// ConnectionSettingsOffers.other_connections field.
  /// Status: [Beta]
  case acceptsOtherConnectionSettings // = 512

  /// The Agent can accept restart requests.
  /// Status: [Beta]
  case acceptsRestartCommand // = 1024

  /// The Agent will report Health via AgentToServer.health field.
  case reportsHealth // = 2048

  /// The Agent will report RemoteConfig status via AgentToServer.remote_config_status field.
  case reportsRemoteConfig // = 4096

  /// The Agent can report heartbeats.
  /// This is specified by the ServerToAgent.OpAMPConnectionSettings.heartbeat_interval_seconds field.
  /// If this capability is true, but the Server does not set a heartbeat_interval_seconds field, the
  /// Agent should use its own configured interval, which by default will be 30s. The Server may not
  /// know the configured interval and should not make assumptions about it.
  /// Status: [Development]
  case reportsHeartbeat // = 8192

  /// The agent will report AvailableComponents via the AgentToServer.available_components field.
  /// Status: [Development]
  case reportsAvailableComponents // = 16384

  /// The agent will report ConnectionSettingsOffers status via AgentToServer.connection_settings_status field.
  /// Status: [Development]
  case reportsConnectionSettingsStatus // = 32768
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .reportsStatus
    case 2: self = .acceptsRemoteConfig
    case 4: self = .reportsEffectiveConfig
    case 8: self = .acceptsPackages
    case 16: self = .reportsPackageStatuses
    case 32: self = .reportsOwnTraces
    case 64: self = .reportsOwnMetrics
    case 128: self = .reportsOwnLogs
    case 256: self = .acceptsOpAmpconnectionSettings
    case 512: self = .acceptsOtherConnectionSettings
    case 1024: self = .acceptsRestartCommand
    case 2048: self = .reportsHealth
    case 4096: self = .reportsRemoteConfig
    case 8192: self = .reportsHeartbeat
    case 16384: self = .reportsAvailableComponents
    case 32768: self = .reportsConnectionSettingsStatus
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .reportsStatus: return 1
    case .acceptsRemoteConfig: return 2
    case .reportsEffectiveConfig: return 4
    case .acceptsPackages: return 8
    case .reportsPackageStatuses: return 16
    case .reportsOwnTraces: return 32
    case .reportsOwnMetrics: return 64
    case .reportsOwnLogs: return 128
    case .acceptsOpAmpconnectionSettings: return 256
    case .acceptsOtherConnectionSettings: return 512
    case .acceptsRestartCommand: return 1024
    case .reportsHealth: return 2048
    case .reportsRemoteConfig: return 4096
    case .reportsHeartbeat: return 8192
    case .reportsAvailableComponents: return 16384
    case .reportsConnectionSettingsStatus: return 32768
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Opamp_Proto_AgentCapabilities] = [
    .unspecified,
    .reportsStatus,
    .acceptsRemoteConfig,
    .reportsEffectiveConfig,
    .acceptsPackages,
    .reportsPackageStatuses,
    .reportsOwnTraces,
    .reportsOwnMetrics,
    .reportsOwnLogs,
    .acceptsOpAmpconnectionSettings,
    .acceptsOtherConnectionSettings,
    .acceptsRestartCommand,
    .reportsHealth,
    .reportsRemoteConfig,
    .reportsHeartbeat,
    .reportsAvailableComponents,
    .reportsConnectionSettingsStatus,
  ]

}

/// Status: [Development]
public enum Opamp_Proto_ConnectionSettingsStatuses: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// The value of status field is not set.
  case unset // = 0

  /// ConnectionSettings were successfully applied by the Agent.
  case applied // = 1

  /// Agent is currently applying the ConnectionSettings that it received.
  case applying // = 2

  /// Agent tried to apply the ConnectionSettings it received earlier, but failed.
  /// See error_message for more details.
  case failed // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unset
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unset
    case 1: self = .applied
    case 2: self = .applying
    case 3: self = .failed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unset: return 0
    case .applied: return 1
    case .applying: return 2
    case .failed: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Opamp_Proto_ConnectionSettingsStatuses] = [
    .unset,
    .applied,
    .applying,
    .failed,
  ]

}

public enum Opamp_Proto_RemoteConfigStatuses: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// The value of status field is not set.
  case unset // = 0

  /// Remote config was successfully applied by the Agent.
  case applied // = 1

  /// Agent is currently applying the remote config that it received earlier.
  case applying // = 2

  /// Agent tried to apply the config received earlier, but it failed.
  /// See error_message for more details.
  case failed // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unset
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unset
    case 1: self = .applied
    case 2: self = .applying
    case 3: self = .failed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unset: return 0
    case .applied: return 1
    case .applying: return 2
    case .failed: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Opamp_Proto_RemoteConfigStatuses] = [
    .unset,
    .applied,
    .applying,
    .failed,
  ]

}

/// The status of this package.
/// Status: [Beta]
public enum Opamp_Proto_PackageStatusEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// Package is successfully installed by the Agent.
  /// The error_message field MUST NOT be set.
  case installed // = 0

  /// Installation of this package has not yet started.
  case installPending // = 1

  /// Agent is currently installing the package.
  /// server_offered_hash field MUST be set to indicate the version that the
  /// Agent is installing. The error_message field MUST NOT be set.
  case installing // = 2

  /// Agent tried to install the package but installation failed.
  /// server_offered_hash field MUST be set to indicate the version that the Agent
  /// tried to install. The error_message may also contain more details about
  /// the failure.
  case installFailed // = 3

  /// Agent is currently downloading the package.
  /// server_offered_hash field MUST be set to indicate the version that the
  /// Agent is installing. The error_message field MUST NOT be set.
  /// Status: [Development]
  case downloading // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .installed
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .installed
    case 1: self = .installPending
    case 2: self = .installing
    case 3: self = .installFailed
    case 4: self = .downloading
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .installed: return 0
    case .installPending: return 1
    case .installing: return 2
    case .installFailed: return 3
    case .downloading: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Opamp_Proto_PackageStatusEnum] = [
    .installed,
    .installPending,
    .installing,
    .installFailed,
    .downloading,
  ]

}

public struct Opamp_Proto_AgentToServer: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Globally unique identifier of the running instance of the Agent. SHOULD remain
  /// unchanged for the lifetime of the Agent process.
  /// MUST be 16 bytes long and SHOULD be generated using the UUID v7 spec.
  public var instanceUid: Data {
    get {return _storage._instanceUid}
    set {_uniqueStorage()._instanceUid = newValue}
  }

  /// The sequence number is incremented by 1 for every AgentToServer sent
  /// by the Agent. This allows the Server to detect that it missed a message when
  /// it notices that the sequence_num is not exactly by 1 greater than the previously
  /// received one.
  public var sequenceNum: UInt64 {
    get {return _storage._sequenceNum}
    set {_uniqueStorage()._sequenceNum = newValue}
  }

  /// Data that describes the Agent, its type, where it runs, etc.
  /// May be omitted if nothing changed since last AgentToServer message.
  public var agentDescription: Opamp_Proto_AgentDescription {
    get {return _storage._agentDescription ?? Opamp_Proto_AgentDescription()}
    set {_uniqueStorage()._agentDescription = newValue}
  }
  /// Returns true if `agentDescription` has been explicitly set.
  public var hasAgentDescription: Bool {return _storage._agentDescription != nil}
  /// Clears the value of `agentDescription`. Subsequent reads from it will return its default value.
  public mutating func clearAgentDescription() {_uniqueStorage()._agentDescription = nil}

  /// Bitmask of flags defined by AgentCapabilities enum.
  /// All bits that are not defined in AgentCapabilities enum MUST be set to 0 by
  /// the Agent. This allows extending the protocol and the AgentCapabilities enum
  /// in the future such that old Agents automatically report that they don't
  /// support the new capability.
  /// This field MUST be always set.
  public var capabilities: UInt64 {
    get {return _storage._capabilities}
    set {_uniqueStorage()._capabilities = newValue}
  }

  /// The current health of the Agent and sub-components. The top-level ComponentHealth represents
  /// the health of the Agent overall. May be omitted if nothing changed since last AgentToServer
  /// message.
  /// Status: [Beta]
  public var health: Opamp_Proto_ComponentHealth {
    get {return _storage._health ?? Opamp_Proto_ComponentHealth()}
    set {_uniqueStorage()._health = newValue}
  }
  /// Returns true if `health` has been explicitly set.
  public var hasHealth: Bool {return _storage._health != nil}
  /// Clears the value of `health`. Subsequent reads from it will return its default value.
  public mutating func clearHealth() {_uniqueStorage()._health = nil}

  /// The current effective configuration of the Agent. The effective configuration is
  /// the one that is currently used by the Agent. The effective configuration may be
  /// different from the remote configuration received from the Server earlier, e.g.
  /// because the Agent uses a local configuration instead (or in addition).
  ///
  /// This field SHOULD be unset if the effective config is unchanged since the last
  /// AgentToServer message.
  public var effectiveConfig: Opamp_Proto_EffectiveConfig {
    get {return _storage._effectiveConfig ?? Opamp_Proto_EffectiveConfig()}
    set {_uniqueStorage()._effectiveConfig = newValue}
  }
  /// Returns true if `effectiveConfig` has been explicitly set.
  public var hasEffectiveConfig: Bool {return _storage._effectiveConfig != nil}
  /// Clears the value of `effectiveConfig`. Subsequent reads from it will return its default value.
  public mutating func clearEffectiveConfig() {_uniqueStorage()._effectiveConfig = nil}

  /// The status of the remote config that was previously received from the Server.
  /// This field SHOULD be unset if the remote config status is unchanged since the
  /// last AgentToServer message.
  public var remoteConfigStatus: Opamp_Proto_RemoteConfigStatus {
    get {return _storage._remoteConfigStatus ?? Opamp_Proto_RemoteConfigStatus()}
    set {_uniqueStorage()._remoteConfigStatus = newValue}
  }
  /// Returns true if `remoteConfigStatus` has been explicitly set.
  public var hasRemoteConfigStatus: Bool {return _storage._remoteConfigStatus != nil}
  /// Clears the value of `remoteConfigStatus`. Subsequent reads from it will return its default value.
  public mutating func clearRemoteConfigStatus() {_uniqueStorage()._remoteConfigStatus = nil}

  /// The list of the Agent packages, including package statuses. This field SHOULD be
  /// unset if this information is unchanged since the last AgentToServer message for
  /// this Agent was sent in the stream.
  /// Status: [Beta]
  public var packageStatuses: Opamp_Proto_PackageStatuses {
    get {return _storage._packageStatuses ?? Opamp_Proto_PackageStatuses()}
    set {_uniqueStorage()._packageStatuses = newValue}
  }
  /// Returns true if `packageStatuses` has been explicitly set.
  public var hasPackageStatuses: Bool {return _storage._packageStatuses != nil}
  /// Clears the value of `packageStatuses`. Subsequent reads from it will return its default value.
  public mutating func clearPackageStatuses() {_uniqueStorage()._packageStatuses = nil}

  /// AgentDisconnect MUST be set in the last AgentToServer message sent from the
  /// Agent to the Server.
  public var agentDisconnect: Opamp_Proto_AgentDisconnect {
    get {return _storage._agentDisconnect ?? Opamp_Proto_AgentDisconnect()}
    set {_uniqueStorage()._agentDisconnect = newValue}
  }
  /// Returns true if `agentDisconnect` has been explicitly set.
  public var hasAgentDisconnect: Bool {return _storage._agentDisconnect != nil}
  /// Clears the value of `agentDisconnect`. Subsequent reads from it will return its default value.
  public mutating func clearAgentDisconnect() {_uniqueStorage()._agentDisconnect = nil}

  /// Bit flags as defined by AgentToServerFlags bit masks.
  public var flags: UInt64 {
    get {return _storage._flags}
    set {_uniqueStorage()._flags = newValue}
  }

  /// A request to create connection settings. This field is set for flows where
  /// the Agent initiates the creation of connection settings.
  /// Status: [Development]
  public var connectionSettingsRequest: Opamp_Proto_ConnectionSettingsRequest {
    get {return _storage._connectionSettingsRequest ?? Opamp_Proto_ConnectionSettingsRequest()}
    set {_uniqueStorage()._connectionSettingsRequest = newValue}
  }
  /// Returns true if `connectionSettingsRequest` has been explicitly set.
  public var hasConnectionSettingsRequest: Bool {return _storage._connectionSettingsRequest != nil}
  /// Clears the value of `connectionSettingsRequest`. Subsequent reads from it will return its default value.
  public mutating func clearConnectionSettingsRequest() {_uniqueStorage()._connectionSettingsRequest = nil}

  /// A message indicating custom capabilities supported by the Agent.
  /// Status: [Development]
  public var customCapabilities: Opamp_Proto_CustomCapabilities {
    get {return _storage._customCapabilities ?? Opamp_Proto_CustomCapabilities()}
    set {_uniqueStorage()._customCapabilities = newValue}
  }
  /// Returns true if `customCapabilities` has been explicitly set.
  public var hasCustomCapabilities: Bool {return _storage._customCapabilities != nil}
  /// Clears the value of `customCapabilities`. Subsequent reads from it will return its default value.
  public mutating func clearCustomCapabilities() {_uniqueStorage()._customCapabilities = nil}

  /// A custom message sent from an Agent to the Server.
  /// Status: [Development]
  public var customMessage: Opamp_Proto_CustomMessage {
    get {return _storage._customMessage ?? Opamp_Proto_CustomMessage()}
    set {_uniqueStorage()._customMessage = newValue}
  }
  /// Returns true if `customMessage` has been explicitly set.
  public var hasCustomMessage: Bool {return _storage._customMessage != nil}
  /// Clears the value of `customMessage`. Subsequent reads from it will return its default value.
  public mutating func clearCustomMessage() {_uniqueStorage()._customMessage = nil}

  /// A message indicating the components that are available for configuration on the agent.
  /// Status: [Development]
  public var availableComponents: Opamp_Proto_AvailableComponents {
    get {return _storage._availableComponents ?? Opamp_Proto_AvailableComponents()}
    set {_uniqueStorage()._availableComponents = newValue}
  }
  /// Returns true if `availableComponents` has been explicitly set.
  public var hasAvailableComponents: Bool {return _storage._availableComponents != nil}
  /// Clears the value of `availableComponents`. Subsequent reads from it will return its default value.
  public mutating func clearAvailableComponents() {_uniqueStorage()._availableComponents = nil}

  /// The status of the OfferedConnectionSettings that was previously received
  /// from the Server. This field SHOULD be unset if the offered connection
  /// settings status is unchanged since the last AgentToServer message.
  /// Status: [Development]
  public var connectionSettingsStatus: Opamp_Proto_ConnectionSettingsStatus {
    get {return _storage._connectionSettingsStatus ?? Opamp_Proto_ConnectionSettingsStatus()}
    set {_uniqueStorage()._connectionSettingsStatus = newValue}
  }
  /// Returns true if `connectionSettingsStatus` has been explicitly set.
  public var hasConnectionSettingsStatus: Bool {return _storage._connectionSettingsStatus != nil}
  /// Clears the value of `connectionSettingsStatus`. Subsequent reads from it will return its default value.
  public mutating func clearConnectionSettingsStatus() {_uniqueStorage()._connectionSettingsStatus = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AgentDisconnect is the last message sent from the Agent to the Server. The Server
/// SHOULD forget the association of the Agent instance with the message stream.
///
/// If the message stream is closed in the transport layer then the Server SHOULD
/// forget association of all Agent instances that were previously established for
/// this message stream using AgentConnect message, even if the corresponding
/// AgentDisconnect message were not explicitly received from the Agent.
public struct Opamp_Proto_AgentDisconnect: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ConnectionSettingsRequest is a request from the Agent to the Server to create
/// and respond with an offer of connection settings for the Agent.
/// Status: [Development]
public struct Opamp_Proto_ConnectionSettingsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Request for OpAMP connection settings. If this field is unset
  /// then the ConnectionSettingsRequest message is empty and is not actionable
  /// for the Server.
  public var opamp: Opamp_Proto_OpAMPConnectionSettingsRequest {
    get {return _opamp ?? Opamp_Proto_OpAMPConnectionSettingsRequest()}
    set {_opamp = newValue}
  }
  /// Returns true if `opamp` has been explicitly set.
  public var hasOpamp: Bool {return self._opamp != nil}
  /// Clears the value of `opamp`. Subsequent reads from it will return its default value.
  public mutating func clearOpamp() {self._opamp = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _opamp: Opamp_Proto_OpAMPConnectionSettingsRequest? = nil
}

/// OpAMPConnectionSettingsRequest is a request for the Server to produce
/// a OpAMPConnectionSettings in its response.
/// Status: [Development]
public struct Opamp_Proto_OpAMPConnectionSettingsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A request to create a client certificate. This is used to initiate a
  /// Client Signing Request (CSR) flow.
  /// Required.
  public var certificateRequest: Opamp_Proto_CertificateRequest {
    get {return _certificateRequest ?? Opamp_Proto_CertificateRequest()}
    set {_certificateRequest = newValue}
  }
  /// Returns true if `certificateRequest` has been explicitly set.
  public var hasCertificateRequest: Bool {return self._certificateRequest != nil}
  /// Clears the value of `certificateRequest`. Subsequent reads from it will return its default value.
  public mutating func clearCertificateRequest() {self._certificateRequest = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _certificateRequest: Opamp_Proto_CertificateRequest? = nil
}

/// Status: [Development]
public struct Opamp_Proto_CertificateRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// PEM-encoded Client Certificate Signing Request (CSR), signed by client's private key.
  /// The Server SHOULD validate the request and SHOULD respond with a
  /// OpAMPConnectionSettings where the certificate.cert contains the issued
  /// certificate.
  public var csr: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// AvailableComponents contains metadata relating to the components included
/// within the agent.
/// status: [Development]
public struct Opamp_Proto_AvailableComponents: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A map of a unique component ID to details about the component.
  /// This may be omitted from the message if the server has not
  /// explicitly requested it be sent by setting the ReportAvailableComponents
  /// flag in the previous ServerToAgent message.
  public var components: Dictionary<String,Opamp_Proto_ComponentDetails> = [:]

  /// Agent-calculated hash of the components.
  /// This hash should be included in every AvailableComponents message.
  public var hash: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Opamp_Proto_ComponentDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Extra key/value pairs that may be used to describe the component.
  /// The key/value pairs are according to semantic conventions, see:
  /// https://opentelemetry.io/docs/specs/semconv/
  ///
  /// For example, you may use the "code" semantic conventions to
  /// report the location of the code for a specific component:
  /// https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
  ///
  /// Or you may use the "vcs" semantic conventions to report the
  /// repository the component may be a part of:
  /// https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
  public var metadata: [Opamp_Proto_KeyValue] = []

  /// A map of component ID to sub components details. It can nest as deeply as needed to
  /// describe the underlying system.
  public var subComponentMap: Dictionary<String,Opamp_Proto_ComponentDetails> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Opamp_Proto_ServerToAgent: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Agent instance uid. MUST match the instance_uid field in AgentToServer message.
  /// Used for multiplexing messages from/to multiple agents using one message stream.
  public var instanceUid: Data {
    get {return _storage._instanceUid}
    set {_uniqueStorage()._instanceUid = newValue}
  }

  /// error_response is set if the Server wants to indicate that something went wrong
  /// during processing of an AgentToServer message. If error_response is set then
  /// all other fields below must be unset and vice versa, if any of the fields below is
  /// set then error_response must be unset.
  public var errorResponse: Opamp_Proto_ServerErrorResponse {
    get {return _storage._errorResponse ?? Opamp_Proto_ServerErrorResponse()}
    set {_uniqueStorage()._errorResponse = newValue}
  }
  /// Returns true if `errorResponse` has been explicitly set.
  public var hasErrorResponse: Bool {return _storage._errorResponse != nil}
  /// Clears the value of `errorResponse`. Subsequent reads from it will return its default value.
  public mutating func clearErrorResponse() {_uniqueStorage()._errorResponse = nil}

  /// remote_config field is set when the Server has a remote config offer for the Agent.
  public var remoteConfig: Opamp_Proto_AgentRemoteConfig {
    get {return _storage._remoteConfig ?? Opamp_Proto_AgentRemoteConfig()}
    set {_uniqueStorage()._remoteConfig = newValue}
  }
  /// Returns true if `remoteConfig` has been explicitly set.
  public var hasRemoteConfig: Bool {return _storage._remoteConfig != nil}
  /// Clears the value of `remoteConfig`. Subsequent reads from it will return its default value.
  public mutating func clearRemoteConfig() {_uniqueStorage()._remoteConfig = nil}

  /// This field is set when the Server wants the Agent to change one or more
  /// of its client connection settings (destination, headers, certificate, etc).
  /// Status: [Beta]
  public var connectionSettings: Opamp_Proto_ConnectionSettingsOffers {
    get {return _storage._connectionSettings ?? Opamp_Proto_ConnectionSettingsOffers()}
    set {_uniqueStorage()._connectionSettings = newValue}
  }
  /// Returns true if `connectionSettings` has been explicitly set.
  public var hasConnectionSettings: Bool {return _storage._connectionSettings != nil}
  /// Clears the value of `connectionSettings`. Subsequent reads from it will return its default value.
  public mutating func clearConnectionSettings() {_uniqueStorage()._connectionSettings = nil}

  /// This field is set when the Server has packages to offer to the Agent.
  /// Status: [Beta]
  public var packagesAvailable: Opamp_Proto_PackagesAvailable {
    get {return _storage._packagesAvailable ?? Opamp_Proto_PackagesAvailable()}
    set {_uniqueStorage()._packagesAvailable = newValue}
  }
  /// Returns true if `packagesAvailable` has been explicitly set.
  public var hasPackagesAvailable: Bool {return _storage._packagesAvailable != nil}
  /// Clears the value of `packagesAvailable`. Subsequent reads from it will return its default value.
  public mutating func clearPackagesAvailable() {_uniqueStorage()._packagesAvailable = nil}

  /// Bit flags as defined by ServerToAgentFlags bit masks.
  public var flags: UInt64 {
    get {return _storage._flags}
    set {_uniqueStorage()._flags = newValue}
  }

  /// Bitmask of flags defined by ServerCapabilities enum.
  /// All bits that are not defined in ServerCapabilities enum MUST be set to 0
  /// by the Server. This allows extending the protocol and the ServerCapabilities
  /// enum in the future such that old Servers automatically report that they
  /// don't support the new capability.
  /// This field MUST be set in the first ServerToAgent sent by the Server and MAY
  /// be omitted in subsequent ServerToAgent messages by setting it to
  /// UnspecifiedServerCapability value.
  public var capabilities: UInt64 {
    get {return _storage._capabilities}
    set {_uniqueStorage()._capabilities = newValue}
  }

  /// Properties related to identification of the Agent, which can be overridden
  /// by the Server if needed.
  public var agentIdentification: Opamp_Proto_AgentIdentification {
    get {return _storage._agentIdentification ?? Opamp_Proto_AgentIdentification()}
    set {_uniqueStorage()._agentIdentification = newValue}
  }
  /// Returns true if `agentIdentification` has been explicitly set.
  public var hasAgentIdentification: Bool {return _storage._agentIdentification != nil}
  /// Clears the value of `agentIdentification`. Subsequent reads from it will return its default value.
  public mutating func clearAgentIdentification() {_uniqueStorage()._agentIdentification = nil}

  /// Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
  /// with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
  /// will be performed.
  /// Status: [Beta]
  public var command: Opamp_Proto_ServerToAgentCommand {
    get {return _storage._command ?? Opamp_Proto_ServerToAgentCommand()}
    set {_uniqueStorage()._command = newValue}
  }
  /// Returns true if `command` has been explicitly set.
  public var hasCommand: Bool {return _storage._command != nil}
  /// Clears the value of `command`. Subsequent reads from it will return its default value.
  public mutating func clearCommand() {_uniqueStorage()._command = nil}

  /// A message indicating custom capabilities supported by the Server.
  /// Status: [Development]
  public var customCapabilities: Opamp_Proto_CustomCapabilities {
    get {return _storage._customCapabilities ?? Opamp_Proto_CustomCapabilities()}
    set {_uniqueStorage()._customCapabilities = newValue}
  }
  /// Returns true if `customCapabilities` has been explicitly set.
  public var hasCustomCapabilities: Bool {return _storage._customCapabilities != nil}
  /// Clears the value of `customCapabilities`. Subsequent reads from it will return its default value.
  public mutating func clearCustomCapabilities() {_uniqueStorage()._customCapabilities = nil}

  /// A custom message sent from the Server to an Agent.
  /// Status: [Development]
  public var customMessage: Opamp_Proto_CustomMessage {
    get {return _storage._customMessage ?? Opamp_Proto_CustomMessage()}
    set {_uniqueStorage()._customMessage = newValue}
  }
  /// Returns true if `customMessage` has been explicitly set.
  public var hasCustomMessage: Bool {return _storage._customMessage != nil}
  /// Clears the value of `customMessage`. Subsequent reads from it will return its default value.
  public mutating func clearCustomMessage() {_uniqueStorage()._customMessage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The OpAMPConnectionSettings message is a collection of fields which comprise an
/// offer from the Server to the Agent to use the specified settings for OpAMP
/// connection.
/// Status: [Beta]
public struct Opamp_Proto_OpAMPConnectionSettings: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// OpAMP Server URL This MUST be a WebSocket or HTTP URL and MUST be non-empty, for
  /// example: "wss://example.com:4318/v1/opamp"
  public var destinationEndpoint: String = String()

  /// Optional headers to use when connecting. Typically used to set access tokens or
  /// other authorization headers. For HTTP-based protocols the Agent should
  /// set these in the request headers.
  /// For example:
  /// key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
  public var headers: Opamp_Proto_Headers {
    get {return _headers ?? Opamp_Proto_Headers()}
    set {_headers = newValue}
  }
  /// Returns true if `headers` has been explicitly set.
  public var hasHeaders: Bool {return self._headers != nil}
  /// Clears the value of `headers`. Subsequent reads from it will return its default value.
  public mutating func clearHeaders() {self._headers = nil}

  /// The Agent should use the offered certificate to connect to the destination
  /// from now on. If the Agent is able to validate and connect using the offered
  /// certificate the Agent SHOULD forget any previous client certificates
  /// for this connection.
  /// This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
  /// This field can be used to perform a client certificate revocation/rotation.
  public var certificate: Opamp_Proto_TLSCertificate {
    get {return _certificate ?? Opamp_Proto_TLSCertificate()}
    set {_certificate = newValue}
  }
  /// Returns true if `certificate` has been explicitly set.
  public var hasCertificate: Bool {return self._certificate != nil}
  /// Clears the value of `certificate`. Subsequent reads from it will return its default value.
  public mutating func clearCertificate() {self._certificate = nil}

  /// The Agent MUST periodically send an AgentToServer message if the
  /// AgentCapabilities_ReportsHeartbeat capability is true. At a minimum the instance_uid
  /// field MUST be set.
  ///
  /// An HTTP Client MUST use the value as polling interval, if heartbeat_interval_seconds is non-zero.
  ///
  /// A heartbeat is used to keep the connection active and inform the server that the Agent
  /// is still alive and active.
  ///
  /// If this field has no value or is set to 0, the Agent should not send any heartbeats.
  /// Status: [Development]
  public var heartbeatIntervalSeconds: UInt64 = 0

  /// Optional connection specific TLS settings.
  /// Status: [Development]
  public var tls: Opamp_Proto_TLSConnectionSettings {
    get {return _tls ?? Opamp_Proto_TLSConnectionSettings()}
    set {_tls = newValue}
  }
  /// Returns true if `tls` has been explicitly set.
  public var hasTls: Bool {return self._tls != nil}
  /// Clears the value of `tls`. Subsequent reads from it will return its default value.
  public mutating func clearTls() {self._tls = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _headers: Opamp_Proto_Headers? = nil
  fileprivate var _certificate: Opamp_Proto_TLSCertificate? = nil
  fileprivate var _tls: Opamp_Proto_TLSConnectionSettings? = nil
}

/// The TelemetryConnectionSettings message is a collection of fields which comprise an
/// offer from the Server to the Agent to use the specified settings for a network
/// connection to report own telemetry.
/// Status: [Beta]
public struct Opamp_Proto_TelemetryConnectionSettings: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The value MUST be a full URL an OTLP/HTTP/Protobuf receiver with path. Schema
  /// SHOULD begin with "https://", for example "https://example.com:4318/v1/metrics"
  /// The Agent MAY refuse to send the telemetry if the URL begins with "http://".
  public var destinationEndpoint: String = String()

  /// Optional headers to use when connecting. Typically used to set access tokens or
  /// other authorization headers. For HTTP-based protocols the Agent should
  /// set these in the request headers.
  /// For example:
  /// key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
  public var headers: Opamp_Proto_Headers {
    get {return _headers ?? Opamp_Proto_Headers()}
    set {_headers = newValue}
  }
  /// Returns true if `headers` has been explicitly set.
  public var hasHeaders: Bool {return self._headers != nil}
  /// Clears the value of `headers`. Subsequent reads from it will return its default value.
  public mutating func clearHeaders() {self._headers = nil}

  /// The Agent should use the offered certificate to connect to the destination
  /// from now on. If the Agent is able to validate and connect using the offered
  /// certificate the Agent SHOULD forget any previous client certificates
  /// for this connection.
  /// This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
  /// This field can be used to perform a client certificate revocation/rotation.
  public var certificate: Opamp_Proto_TLSCertificate {
    get {return _certificate ?? Opamp_Proto_TLSCertificate()}
    set {_certificate = newValue}
  }
  /// Returns true if `certificate` has been explicitly set.
  public var hasCertificate: Bool {return self._certificate != nil}
  /// Clears the value of `certificate`. Subsequent reads from it will return its default value.
  public mutating func clearCertificate() {self._certificate = nil}

  /// Optional connection specific TLS settings.
  /// Status: [Development]
  public var tls: Opamp_Proto_TLSConnectionSettings {
    get {return _tls ?? Opamp_Proto_TLSConnectionSettings()}
    set {_tls = newValue}
  }
  /// Returns true if `tls` has been explicitly set.
  public var hasTls: Bool {return self._tls != nil}
  /// Clears the value of `tls`. Subsequent reads from it will return its default value.
  public mutating func clearTls() {self._tls = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _headers: Opamp_Proto_Headers? = nil
  fileprivate var _certificate: Opamp_Proto_TLSCertificate? = nil
  fileprivate var _tls: Opamp_Proto_TLSConnectionSettings? = nil
}

/// The OtherConnectionSettings message is a collection of fields which comprise an
/// offer from the Server to the Agent to use the specified settings for a network
/// connection. It is not required that all fields in this message are specified.
/// The Server may specify only some of the fields, in which case it means that
/// the Server offers the Agent to change only those fields, while keeping the
/// rest of the fields unchanged.
///
/// For example the Server may send a ConnectionSettings message with only the
/// certificate field set, while all other fields are unset. This means that
/// the Server wants the Agent to use a new certificate and continue sending to
/// the destination it is currently sending using the current header and other
/// settings.
///
/// For fields which reference other messages the field is considered unset
/// when the reference is unset.
///
/// For primitive field (string) we rely on the "flags" to describe that the
/// field is not set (this is done to overcome the limitation of old protoc
/// compilers don't generate methods that allow to check for the presence of
/// the field.
/// Status: [Beta]
public struct Opamp_Proto_OtherConnectionSettings: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A URL, host:port or some other destination specifier.
  public var destinationEndpoint: String = String()

  /// Optional headers to use when connecting. Typically used to set access tokens or
  /// other authorization headers. For HTTP-based protocols the Agent should
  /// set these in the request headers.
  /// For example:
  /// key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
  public var headers: Opamp_Proto_Headers {
    get {return _headers ?? Opamp_Proto_Headers()}
    set {_headers = newValue}
  }
  /// Returns true if `headers` has been explicitly set.
  public var hasHeaders: Bool {return self._headers != nil}
  /// Clears the value of `headers`. Subsequent reads from it will return its default value.
  public mutating func clearHeaders() {self._headers = nil}

  /// The Agent should use the offered certificate to connect to the destination
  /// from now on. If the Agent is able to validate and connect using the offered
  /// certificate the Agent SHOULD forget any previous client certificates
  /// for this connection.
  /// This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
  /// This field can be used to perform a client certificate revocation/rotation.
  public var certificate: Opamp_Proto_TLSCertificate {
    get {return _certificate ?? Opamp_Proto_TLSCertificate()}
    set {_certificate = newValue}
  }
  /// Returns true if `certificate` has been explicitly set.
  public var hasCertificate: Bool {return self._certificate != nil}
  /// Clears the value of `certificate`. Subsequent reads from it will return its default value.
  public mutating func clearCertificate() {self._certificate = nil}

  /// Other connection settings. These are Agent-specific and are up to the Agent
  /// interpret.
  public var otherSettings: Dictionary<String,String> = [:]

  /// Optional connection specific TLS settings.
  /// Status: [Development]
  public var tls: Opamp_Proto_TLSConnectionSettings {
    get {return _tls ?? Opamp_Proto_TLSConnectionSettings()}
    set {_tls = newValue}
  }
  /// Returns true if `tls` has been explicitly set.
  public var hasTls: Bool {return self._tls != nil}
  /// Clears the value of `tls`. Subsequent reads from it will return its default value.
  public mutating func clearTls() {self._tls = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _headers: Opamp_Proto_Headers? = nil
  fileprivate var _certificate: Opamp_Proto_TLSCertificate? = nil
  fileprivate var _tls: Opamp_Proto_TLSConnectionSettings? = nil
}

/// TLSConnectionSettings are optional connection settings that can be passed to
/// the client in order to specify TLS configuration.
/// Status: [Development]
public struct Opamp_Proto_TLSConnectionSettings: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Provides CA cert contents as a string.
  public var caPemContents: String = String()

  /// Load system CA pool alongside any passed CAs.
  public var includeSystemCaCertsPool: Bool = false

  /// skip certificate verification.
  public var insecureSkipVerify: Bool = false

  /// Miniumum accepted TLS version; default "1.2".
  public var minVersion: String = String()

  /// Maxiumum accepted TLS version; default "".
  public var maxVersion: String = String()

  /// Explicit list of cipher suites.
  public var cipherSuites: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Status: [Beta]
public struct Opamp_Proto_Headers: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var headers: [Opamp_Proto_Header] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Status: [Beta]
public struct Opamp_Proto_Header: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String = String()

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Status: [Beta]
public struct Opamp_Proto_TLSCertificate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// PEM-encoded certificate. Required.
  public var cert: Data = Data()

  /// PEM-encoded private key of the certificate. Required.
  public var privateKey: Data = Data()

  /// PEM-encoded certificate of the signing CA.
  /// Optional. MUST be specified if the certificate is CA-signed.
  /// Can be stored by TLS-terminating intermediary proxies in order to verify
  /// the connecting client's certificate in the future.
  /// It is not recommended that the Agent accepts this CA as an authority for
  /// any purposes.
  public var caCert: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Status: [Beta]
public struct Opamp_Proto_ConnectionSettingsOffers: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Hash of all settings, including settings that may be omitted from this message
  /// because they are unchanged.
  public var hash: Data {
    get {return _storage._hash}
    set {_uniqueStorage()._hash = newValue}
  }

  /// Settings to connect to the OpAMP Server.
  /// If this field is not set then the Agent should assume that the settings are
  /// unchanged and should continue using existing settings.
  /// The Agent MUST verify the offered connection settings by actually connecting
  /// before accepting the setting to ensure it does not loose access to the OpAMP
  /// Server due to invalid settings.
  public var opamp: Opamp_Proto_OpAMPConnectionSettings {
    get {return _storage._opamp ?? Opamp_Proto_OpAMPConnectionSettings()}
    set {_uniqueStorage()._opamp = newValue}
  }
  /// Returns true if `opamp` has been explicitly set.
  public var hasOpamp: Bool {return _storage._opamp != nil}
  /// Clears the value of `opamp`. Subsequent reads from it will return its default value.
  public mutating func clearOpamp() {_uniqueStorage()._opamp = nil}

  /// Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
  /// If this field is not set then the Agent should assume that the settings
  /// are unchanged.
  ///
  /// Once accepted the Agent should periodically send to the specified destination
  /// its own metrics, i.e. metrics of the Agent process and any custom metrics that
  /// describe the Agent state.
  ///
  /// All attributes specified in the identifying_attributes field in AgentDescription
  /// message SHOULD be also specified in the Resource of the reported OTLP metrics.
  ///
  /// Attributes specified in the non_identifying_attributes field in
  /// AgentDescription message may be also specified in the Resource of the reported
  /// OTLP metrics, in which case they SHOULD have exactly the same values.
  ///
  /// Process metrics MUST follow the conventions for processes:
  /// https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
  public var ownMetrics: Opamp_Proto_TelemetryConnectionSettings {
    get {return _storage._ownMetrics ?? Opamp_Proto_TelemetryConnectionSettings()}
    set {_uniqueStorage()._ownMetrics = newValue}
  }
  /// Returns true if `ownMetrics` has been explicitly set.
  public var hasOwnMetrics: Bool {return _storage._ownMetrics != nil}
  /// Clears the value of `ownMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearOwnMetrics() {_uniqueStorage()._ownMetrics = nil}

  /// Similar to own_metrics, but for traces.
  public var ownTraces: Opamp_Proto_TelemetryConnectionSettings {
    get {return _storage._ownTraces ?? Opamp_Proto_TelemetryConnectionSettings()}
    set {_uniqueStorage()._ownTraces = newValue}
  }
  /// Returns true if `ownTraces` has been explicitly set.
  public var hasOwnTraces: Bool {return _storage._ownTraces != nil}
  /// Clears the value of `ownTraces`. Subsequent reads from it will return its default value.
  public mutating func clearOwnTraces() {_uniqueStorage()._ownTraces = nil}

  /// Similar to own_metrics, but for logs.
  public var ownLogs: Opamp_Proto_TelemetryConnectionSettings {
    get {return _storage._ownLogs ?? Opamp_Proto_TelemetryConnectionSettings()}
    set {_uniqueStorage()._ownLogs = newValue}
  }
  /// Returns true if `ownLogs` has been explicitly set.
  public var hasOwnLogs: Bool {return _storage._ownLogs != nil}
  /// Clears the value of `ownLogs`. Subsequent reads from it will return its default value.
  public mutating func clearOwnLogs() {_uniqueStorage()._ownLogs = nil}

  /// Another set of connection settings, with a string name associated with each.
  /// How the Agent uses these is Agent-specific. Typically the name represents
  /// the name of the destination to connect to (as it is known to the Agent).
  /// If this field is not set then the Agent should assume that the other_connections
  /// settings are unchanged.
  public var otherConnections: Dictionary<String,Opamp_Proto_OtherConnectionSettings> {
    get {return _storage._otherConnections}
    set {_uniqueStorage()._otherConnections = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// List of packages that the Server offers to the Agent.
/// Status: [Beta]
public struct Opamp_Proto_PackagesAvailable: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Map of packages. Keys are package names, values are the packages available for download.
  public var packages: Dictionary<String,Opamp_Proto_PackageAvailable> = [:]

  /// Aggregate hash of all remotely installed packages. The Agent SHOULD include this
  /// value in subsequent PackageStatuses messages. This in turn allows the management
  /// Server to identify that a different set of packages is available for the Agent
  /// and specify the available packages in the next ServerToAgent message.
  ///
  /// This field MUST be always set if the management Server supports packages
  /// of agents.
  ///
  /// The hash is calculated as an aggregate of all packages names and content.
  public var allPackagesHash: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Each Agent is composed of one or more packages. A package has a name and
/// content stored in a file. The content of the files, functionality
/// provided by the packages, how they are stored and used by the Agent side is Agent
/// type-specific and is outside the concerns of the OpAMP protocol.
///
/// If the Agent does not have an installed package with the specified name then
/// it SHOULD download it from the specified URL and install it.
///
/// If the Agent already has an installed package with the specified name
/// but with a different hash then the Agent SHOULD download and
/// install the package again, since it is a different version of the same package.
///
/// If the Agent has an installed package with the specified name and the same
/// hash then the Agent does not need to do anything, it already
/// has the right version of the package.
/// Status: [Beta]
public struct Opamp_Proto_PackageAvailable: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Opamp_Proto_PackageType = .topLevel

  /// The package version that is available on the Server side. The Agent may for
  /// example use this information to avoid downloading a package that was previously
  /// already downloaded and failed to install.
  public var version: String = String()

  /// The downloadable file of the package.
  public var file: Opamp_Proto_DownloadableFile {
    get {return _file ?? Opamp_Proto_DownloadableFile()}
    set {_file = newValue}
  }
  /// Returns true if `file` has been explicitly set.
  public var hasFile: Bool {return self._file != nil}
  /// Clears the value of `file`. Subsequent reads from it will return its default value.
  public mutating func clearFile() {self._file = nil}

  /// The hash of the package. SHOULD be calculated based on all other fields of the
  /// PackageAvailable message and content of the file of the package. The hash is
  /// used by the Agent to determine if the package it has is different from the
  /// package the Server is offering.
  public var hash: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _file: Opamp_Proto_DownloadableFile? = nil
}

/// Status: [Beta]
public struct Opamp_Proto_DownloadableFile: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The URL from which the file can be downloaded using HTTP GET request.
  /// The Server at the specified URL SHOULD support range requests
  /// to allow for resuming downloads.
  public var downloadURL: String = String()

  /// The hash of the file content. Can be used by the Agent to verify that the file
  /// was downloaded correctly.
  public var contentHash: Data = Data()

  /// Optional signature of the file content. Can be used by the Agent to verify the
  /// authenticity of the downloaded file, for example can be the
  /// [detached GPG signature](https://www.gnupg.org/gph/en/manual/x135.html#AEN160).
  /// The exact signing and verification method is Agent specific. See
  /// https://github.com/open-telemetry/opamp-spec/blob/main/specification.md#code-signing
  /// for recommendations.
  public var signature: Data = Data()

  /// Optional headers to use when downloading a file. Typically used to set
  /// access tokens or other authorization headers. For HTTP-based protocols
  /// the Agent should set these in the request headers.
  /// For example:
  /// key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
  /// Status: [Development]
  public var headers: Opamp_Proto_Headers {
    get {return _headers ?? Opamp_Proto_Headers()}
    set {_headers = newValue}
  }
  /// Returns true if `headers` has been explicitly set.
  public var hasHeaders: Bool {return self._headers != nil}
  /// Clears the value of `headers`. Subsequent reads from it will return its default value.
  public mutating func clearHeaders() {self._headers = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _headers: Opamp_Proto_Headers? = nil
}

public struct Opamp_Proto_ServerErrorResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Opamp_Proto_ServerErrorResponseType = .unknown

  /// Error message in the string form, typically human readable.
  public var errorMessage: String = String()

  public var details: Opamp_Proto_ServerErrorResponse.OneOf_Details? = nil

  /// Additional information about retrying if type==UNAVAILABLE.
  public var retryInfo: Opamp_Proto_RetryInfo {
    get {
      if case .retryInfo(let v)? = details {return v}
      return Opamp_Proto_RetryInfo()
    }
    set {details = .retryInfo(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Details: Equatable, Sendable {
    /// Additional information about retrying if type==UNAVAILABLE.
    case retryInfo(Opamp_Proto_RetryInfo)

  }

  public init() {}
}

public struct Opamp_Proto_RetryInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var retryAfterNanoseconds: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ServerToAgentCommand is sent from the Server to the Agent to request that the Agent
/// perform a command.
/// Status: [Beta]
public struct Opamp_Proto_ServerToAgentCommand: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Opamp_Proto_CommandType = .restart

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Opamp_Proto_AgentDescription: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Attributes that identify the Agent.
  /// Keys/values are according to OpenTelemetry semantic conventions, see:
  /// https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
  ///
  /// For standalone running Agents (such as OpenTelemetry Collector) the following
  /// attributes SHOULD be specified:
  /// - service.name should be set to a reverse FQDN that uniquely identifies the
  ///   Agent type, e.g. "io.opentelemetry.collector"
  /// - service.namespace if it is used in the environment where the Agent runs.
  /// - service.version should be set to version number of the Agent build.
  /// - service.instance.id should be set. It may be set equal to the Agent's
  ///   instance uid (equal to ServerToAgent.instance_uid field) or any other value
  ///   that uniquely identifies the Agent in combination with other attributes.
  /// - any other attributes that are necessary for uniquely identifying the Agent's
  ///   own telemetry.
  ///
  /// The Agent SHOULD also include these attributes in the Resource of its own
  /// telemetry. The combination of identifying attributes SHOULD be sufficient to
  /// uniquely identify the Agent's own telemetry in the destination system to which
  /// the Agent sends its own telemetry.
  public var identifyingAttributes: [Opamp_Proto_KeyValue] = []

  /// Attributes that do not necessarily identify the Agent but help describe
  /// where it runs.
  /// The following attributes SHOULD be included:
  /// - os.type, os.version - to describe where the Agent runs.
  /// - host.* to describe the host the Agent runs on.
  /// - cloud.* to describe the cloud where the host is located.
  /// - any other relevant Resource attributes that describe this Agent and the
  ///   environment it runs in.
  /// - any user-defined attributes that the end user would like to associate
  ///   with this Agent.
  public var nonIdentifyingAttributes: [Opamp_Proto_KeyValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The health of the Agent and sub-components
/// Status: [Beta]
public struct Opamp_Proto_ComponentHealth: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Set to true if the component is up and healthy.
  public var healthy: Bool = false

  /// Timestamp since the component is up, i.e. when the component was started.
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
  /// If the component is not running MUST be set to 0.
  public var startTimeUnixNano: UInt64 = 0

  /// Human-readable error message if the component is in erroneous state. SHOULD be set
  /// when healthy==false.
  public var lastError: String = String()

  /// Component status represented as a string. The status values are defined by agent-specific
  /// semantics and not at the protocol level.
  public var status: String = String()

  /// The time when the component status was observed. Value is UNIX Epoch time in
  /// nanoseconds since 00:00:00 UTC on 1 January 1970.
  public var statusTimeUnixNano: UInt64 = 0

  /// A map to store more granular, sub-component health. It can nest as deeply as needed to
  /// describe the underlying system.
  public var componentHealthMap: Dictionary<String,Opamp_Proto_ComponentHealth> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Opamp_Proto_EffectiveConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The effective config of the Agent.
  public var configMap: Opamp_Proto_AgentConfigMap {
    get {return _configMap ?? Opamp_Proto_AgentConfigMap()}
    set {_configMap = newValue}
  }
  /// Returns true if `configMap` has been explicitly set.
  public var hasConfigMap: Bool {return self._configMap != nil}
  /// Clears the value of `configMap`. Subsequent reads from it will return its default value.
  public mutating func clearConfigMap() {self._configMap = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _configMap: Opamp_Proto_AgentConfigMap? = nil
}

public struct Opamp_Proto_RemoteConfigStatus: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The hash of the remote config that was last received by this Agent in the
  /// AgentRemoteConfig.config_hash field.
  /// The Server SHOULD compare this hash with the config hash
  /// it has for the Agent and if the hashes are different the Server MUST include
  /// the remote_config field in the response in the ServerToAgent message.
  public var lastRemoteConfigHash: Data = Data()

  public var status: Opamp_Proto_RemoteConfigStatuses = .unset

  /// Optional error message if status==FAILED.
  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Status: [Development]
public struct Opamp_Proto_ConnectionSettingsStatus: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The hash of the connection settings that was last recieved by this Agent
  /// in the connection_settings.hash field. The Server SHOULD compare this
  /// hash with the OfferedConnectionSettings hash it has for the Agent and if
  /// the hashes are different the Server MUST include the connection_settings
  /// field in the response in the ServerToAgent message.
  public var lastConnectionSettingsHash: Data = Data()

  public var status: Opamp_Proto_ConnectionSettingsStatuses = .unset

  /// Optional error message if status==FAILED.
  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The PackageStatuses message describes the status of all packages that the Agent
/// has or was offered.
/// Status: [Beta]
public struct Opamp_Proto_PackageStatuses: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A map of PackageStatus messages, where the keys are package names.
  /// The key MUST match the name field of PackageStatus message.
  public var packages: Dictionary<String,Opamp_Proto_PackageStatus> = [:]

  /// The aggregate hash of all packages that this Agent previously received from the
  /// Server via PackagesAvailable message.
  ///
  /// The Server SHOULD compare this hash to the aggregate hash of all packages that
  /// it has for this Agent and if the hashes are different the Server SHOULD send
  /// an PackagesAvailable message to the Agent.
  public var serverProvidedAllPackagesHash: Data = Data()

  /// This field is set if the Agent encountered an error when processing the
  /// PackagesAvailable message and that error is not related to any particular single
  /// package.
  /// The field must be unset is there were no processing errors.
  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The status of a single package.
/// Status: [Beta]
public struct Opamp_Proto_PackageStatus: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Package name. MUST be always set and MUST match the key in the packages field
  /// of PackageStatuses message.
  public var name: String = String()

  /// The version of the package that the Agent has.
  /// MUST be set if the Agent has this package.
  /// MUST be empty if the Agent does not have this package. This may be the case
  /// for example if the package was offered by the Server but failed to install
  /// and the Agent did not have this package previously.
  public var agentHasVersion: String = String()

  /// The hash of the package that the Agent has.
  /// MUST be set if the Agent has this package.
  /// MUST be empty if the Agent does not have this package. This may be the case for
  /// example if the package was offered by the Server but failed to install and the
  /// Agent did not have this package previously.
  public var agentHasHash: Data = Data()

  /// The version of the package that the Server offered to the Agent.
  /// MUST be set if the installation of the package is initiated by an earlier offer
  /// from the Server to install this package.
  ///
  /// MUST be empty if the Agent has this package but it was installed locally and
  /// was not offered by the Server.
  ///
  /// Note that it is possible for both agent_has_version and server_offered_version
  /// fields to be set and to have different values. This is for example possible if
  /// the Agent already has a version of the package successfully installed, the Server
  /// offers a different version, but the Agent fails to install that version.
  public var serverOfferedVersion: String = String()

  /// The hash of the package that the Server offered to the Agent.
  /// MUST be set if the installation of the package is initiated by an earlier
  /// offer from the Server to install this package.
  ///
  /// MUST be empty if the Agent has this package but it was installed locally and
  /// was not offered by the Server.
  ///
  /// Note that it is possible for both agent_has_hash and server_offered_hash
  /// fields to be set and to have different values. This is for example possible if
  /// the Agent already has a version of the package successfully installed, the
  /// Server offers a different version, but the Agent fails to install that version.
  public var serverOfferedHash: Data = Data()

  public var status: Opamp_Proto_PackageStatusEnum = .installed

  /// Error message if the status is erroneous.
  public var errorMessage: String = String()

  /// Optional details that may be of interest to a user.
  /// Should only be set if status is Downloading.
  /// Status: [Development]
  public var downloadDetails: Opamp_Proto_PackageDownloadDetails {
    get {return _downloadDetails ?? Opamp_Proto_PackageDownloadDetails()}
    set {_downloadDetails = newValue}
  }
  /// Returns true if `downloadDetails` has been explicitly set.
  public var hasDownloadDetails: Bool {return self._downloadDetails != nil}
  /// Clears the value of `downloadDetails`. Subsequent reads from it will return its default value.
  public mutating func clearDownloadDetails() {self._downloadDetails = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _downloadDetails: Opamp_Proto_PackageDownloadDetails? = nil
}

/// Additional details that an agent can use to describe an in-progress package download.
/// Status: [Development]
public struct Opamp_Proto_PackageDownloadDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The package download progress as a percentage.
  public var downloadPercent: Double = 0

  /// The current package download rate in bytes per second.
  public var downloadBytesPerSecond: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Properties related to identification of the Agent, which can be overridden
/// by the Server if needed
public struct Opamp_Proto_AgentIdentification: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// When new_instance_uid is set, Agent MUST update instance_uid
  /// to the value provided and use it for all further communication.
  /// MUST be 16 bytes long and SHOULD be generated using the UUID v7 spec.
  public var newInstanceUid: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Opamp_Proto_AgentRemoteConfig: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Agent config offered by the management Server to the Agent instance. SHOULD NOT be
  /// set if the config for this Agent has not changed since it was last requested (i.e.
  /// AgentConfigRequest.last_remote_config_hash field is equal to
  /// AgentConfigResponse.config_hash field).
  public var config: Opamp_Proto_AgentConfigMap {
    get {return _config ?? Opamp_Proto_AgentConfigMap()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {self._config = nil}

  /// Hash of "config". The Agent SHOULD include this value in subsequent
  /// RemoteConfigStatus messages in the last_remote_config_hash field. This in turn
  /// allows the management Server to identify that a new config is available for the Agent.
  ///
  /// This field MUST be always set if the management Server supports remote configuration
  /// of agents.
  ///
  /// Management Server must choose a hashing function that guarantees lack of hash
  /// collisions in practice.
  public var configHash: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _config: Opamp_Proto_AgentConfigMap? = nil
}

public struct Opamp_Proto_AgentConfigMap: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Map of configs. Keys are config file names or config section names.
  /// The configuration is assumed to be a collection of one or more named config files
  /// or sections.
  /// For agents that use a single config file or section the map SHOULD contain a single
  /// entry and the key may be an empty string.
  public var configMap: Dictionary<String,Opamp_Proto_AgentConfigFile> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Opamp_Proto_AgentConfigFile: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Config file or section body. The content, format and encoding depends on the Agent
  /// type. The content_type field may optionally describe the MIME type of the body.
  public var body: Data = Data()

  /// Optional MIME Content-Type that describes what's in the body field, for
  /// example "text/yaml".
  public var contentType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Opamp_Proto_CustomCapabilities: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of custom capabilities that are supported. Each capability is a reverse FQDN
  /// with optional version information that uniquely identifies the custom capability
  /// and should match a capability specified in a supported CustomMessage.
  /// Status: [Development]
  public var capabilities: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Opamp_Proto_CustomMessage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A reverse FQDN that uniquely identifies the capability and matches one of the
  /// capabilities in the CustomCapabilities message.
  /// Status: [Development]
  public var capability: String = String()

  /// Type of message within the capability. The capability defines the types of custom
  /// messages that are used to implement the capability. The type must only be unique
  /// within the capability.
  /// Status: [Development]
  public var type: String = String()

  /// Binary data of the message. The capability must specify the format of the contents
  /// of the data for each custom message type it defines.
  /// Status: [Development]
  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "opamp.proto"

extension Opamp_Proto_AgentToServerFlags: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AgentToServerFlags_Unspecified"),
    1: .same(proto: "AgentToServerFlags_RequestInstanceUid"),
  ]
}

extension Opamp_Proto_ServerToAgentFlags: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ServerToAgentFlags_Unspecified"),
    1: .same(proto: "ServerToAgentFlags_ReportFullState"),
    2: .same(proto: "ServerToAgentFlags_ReportAvailableComponents"),
  ]
}

extension Opamp_Proto_ServerCapabilities: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ServerCapabilities_Unspecified"),
    1: .same(proto: "ServerCapabilities_AcceptsStatus"),
    2: .same(proto: "ServerCapabilities_OffersRemoteConfig"),
    4: .same(proto: "ServerCapabilities_AcceptsEffectiveConfig"),
    8: .same(proto: "ServerCapabilities_OffersPackages"),
    16: .same(proto: "ServerCapabilities_AcceptsPackagesStatus"),
    32: .same(proto: "ServerCapabilities_OffersConnectionSettings"),
    64: .same(proto: "ServerCapabilities_AcceptsConnectionSettingsRequest"),
  ]
}

extension Opamp_Proto_PackageType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PackageType_TopLevel"),
    1: .same(proto: "PackageType_Addon"),
  ]
}

extension Opamp_Proto_ServerErrorResponseType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ServerErrorResponseType_Unknown"),
    1: .same(proto: "ServerErrorResponseType_BadRequest"),
    2: .same(proto: "ServerErrorResponseType_Unavailable"),
  ]
}

extension Opamp_Proto_CommandType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CommandType_Restart"),
  ]
}

extension Opamp_Proto_AgentCapabilities: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AgentCapabilities_Unspecified"),
    1: .same(proto: "AgentCapabilities_ReportsStatus"),
    2: .same(proto: "AgentCapabilities_AcceptsRemoteConfig"),
    4: .same(proto: "AgentCapabilities_ReportsEffectiveConfig"),
    8: .same(proto: "AgentCapabilities_AcceptsPackages"),
    16: .same(proto: "AgentCapabilities_ReportsPackageStatuses"),
    32: .same(proto: "AgentCapabilities_ReportsOwnTraces"),
    64: .same(proto: "AgentCapabilities_ReportsOwnMetrics"),
    128: .same(proto: "AgentCapabilities_ReportsOwnLogs"),
    256: .same(proto: "AgentCapabilities_AcceptsOpAMPConnectionSettings"),
    512: .same(proto: "AgentCapabilities_AcceptsOtherConnectionSettings"),
    1024: .same(proto: "AgentCapabilities_AcceptsRestartCommand"),
    2048: .same(proto: "AgentCapabilities_ReportsHealth"),
    4096: .same(proto: "AgentCapabilities_ReportsRemoteConfig"),
    8192: .same(proto: "AgentCapabilities_ReportsHeartbeat"),
    16384: .same(proto: "AgentCapabilities_ReportsAvailableComponents"),
    32768: .same(proto: "AgentCapabilities_ReportsConnectionSettingsStatus"),
  ]
}

extension Opamp_Proto_ConnectionSettingsStatuses: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ConnectionSettingsStatuses_UNSET"),
    1: .same(proto: "ConnectionSettingsStatuses_APPLIED"),
    2: .same(proto: "ConnectionSettingsStatuses_APPLYING"),
    3: .same(proto: "ConnectionSettingsStatuses_FAILED"),
  ]
}

extension Opamp_Proto_RemoteConfigStatuses: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RemoteConfigStatuses_UNSET"),
    1: .same(proto: "RemoteConfigStatuses_APPLIED"),
    2: .same(proto: "RemoteConfigStatuses_APPLYING"),
    3: .same(proto: "RemoteConfigStatuses_FAILED"),
  ]
}

extension Opamp_Proto_PackageStatusEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PackageStatusEnum_Installed"),
    1: .same(proto: "PackageStatusEnum_InstallPending"),
    2: .same(proto: "PackageStatusEnum_Installing"),
    3: .same(proto: "PackageStatusEnum_InstallFailed"),
    4: .same(proto: "PackageStatusEnum_Downloading"),
  ]
}

extension Opamp_Proto_AgentToServer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AgentToServer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instance_uid"),
    2: .standard(proto: "sequence_num"),
    3: .standard(proto: "agent_description"),
    4: .same(proto: "capabilities"),
    5: .same(proto: "health"),
    6: .standard(proto: "effective_config"),
    7: .standard(proto: "remote_config_status"),
    8: .standard(proto: "package_statuses"),
    9: .standard(proto: "agent_disconnect"),
    10: .same(proto: "flags"),
    11: .standard(proto: "connection_settings_request"),
    12: .standard(proto: "custom_capabilities"),
    13: .standard(proto: "custom_message"),
    14: .standard(proto: "available_components"),
    15: .standard(proto: "connection_settings_status"),
  ]

  fileprivate class _StorageClass {
    var _instanceUid: Data = Data()
    var _sequenceNum: UInt64 = 0
    var _agentDescription: Opamp_Proto_AgentDescription? = nil
    var _capabilities: UInt64 = 0
    var _health: Opamp_Proto_ComponentHealth? = nil
    var _effectiveConfig: Opamp_Proto_EffectiveConfig? = nil
    var _remoteConfigStatus: Opamp_Proto_RemoteConfigStatus? = nil
    var _packageStatuses: Opamp_Proto_PackageStatuses? = nil
    var _agentDisconnect: Opamp_Proto_AgentDisconnect? = nil
    var _flags: UInt64 = 0
    var _connectionSettingsRequest: Opamp_Proto_ConnectionSettingsRequest? = nil
    var _customCapabilities: Opamp_Proto_CustomCapabilities? = nil
    var _customMessage: Opamp_Proto_CustomMessage? = nil
    var _availableComponents: Opamp_Proto_AvailableComponents? = nil
    var _connectionSettingsStatus: Opamp_Proto_ConnectionSettingsStatus? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _instanceUid = source._instanceUid
      _sequenceNum = source._sequenceNum
      _agentDescription = source._agentDescription
      _capabilities = source._capabilities
      _health = source._health
      _effectiveConfig = source._effectiveConfig
      _remoteConfigStatus = source._remoteConfigStatus
      _packageStatuses = source._packageStatuses
      _agentDisconnect = source._agentDisconnect
      _flags = source._flags
      _connectionSettingsRequest = source._connectionSettingsRequest
      _customCapabilities = source._customCapabilities
      _customMessage = source._customMessage
      _availableComponents = source._availableComponents
      _connectionSettingsStatus = source._connectionSettingsStatus
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._instanceUid) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._sequenceNum) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._agentDescription) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._capabilities) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._health) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._effectiveConfig) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._remoteConfigStatus) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._packageStatuses) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._agentDisconnect) }()
        case 10: try { try decoder.decodeSingularUInt64Field(value: &_storage._flags) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._connectionSettingsRequest) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._customCapabilities) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._customMessage) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._availableComponents) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._connectionSettingsStatus) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._instanceUid.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._instanceUid, fieldNumber: 1)
      }
      if _storage._sequenceNum != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._sequenceNum, fieldNumber: 2)
      }
      try { if let v = _storage._agentDescription {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._capabilities != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._capabilities, fieldNumber: 4)
      }
      try { if let v = _storage._health {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._effectiveConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._remoteConfigStatus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._packageStatuses {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._agentDisconnect {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._flags != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._flags, fieldNumber: 10)
      }
      try { if let v = _storage._connectionSettingsRequest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._customCapabilities {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._customMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._availableComponents {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._connectionSettingsStatus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_AgentToServer, rhs: Opamp_Proto_AgentToServer) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._instanceUid != rhs_storage._instanceUid {return false}
        if _storage._sequenceNum != rhs_storage._sequenceNum {return false}
        if _storage._agentDescription != rhs_storage._agentDescription {return false}
        if _storage._capabilities != rhs_storage._capabilities {return false}
        if _storage._health != rhs_storage._health {return false}
        if _storage._effectiveConfig != rhs_storage._effectiveConfig {return false}
        if _storage._remoteConfigStatus != rhs_storage._remoteConfigStatus {return false}
        if _storage._packageStatuses != rhs_storage._packageStatuses {return false}
        if _storage._agentDisconnect != rhs_storage._agentDisconnect {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._connectionSettingsRequest != rhs_storage._connectionSettingsRequest {return false}
        if _storage._customCapabilities != rhs_storage._customCapabilities {return false}
        if _storage._customMessage != rhs_storage._customMessage {return false}
        if _storage._availableComponents != rhs_storage._availableComponents {return false}
        if _storage._connectionSettingsStatus != rhs_storage._connectionSettingsStatus {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_AgentDisconnect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AgentDisconnect"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_AgentDisconnect, rhs: Opamp_Proto_AgentDisconnect) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_ConnectionSettingsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectionSettingsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "opamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._opamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._opamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_ConnectionSettingsRequest, rhs: Opamp_Proto_ConnectionSettingsRequest) -> Bool {
    if lhs._opamp != rhs._opamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_OpAMPConnectionSettingsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpAMPConnectionSettingsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "certificate_request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._certificateRequest) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._certificateRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_OpAMPConnectionSettingsRequest, rhs: Opamp_Proto_OpAMPConnectionSettingsRequest) -> Bool {
    if lhs._certificateRequest != rhs._certificateRequest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_CertificateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CertificateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "csr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.csr) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.csr.isEmpty {
      try visitor.visitSingularBytesField(value: self.csr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_CertificateRequest, rhs: Opamp_Proto_CertificateRequest) -> Bool {
    if lhs.csr != rhs.csr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_AvailableComponents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AvailableComponents"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "components"),
    2: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opamp_Proto_ComponentDetails>.self, value: &self.components) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.components.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opamp_Proto_ComponentDetails>.self, value: self.components, fieldNumber: 1)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_AvailableComponents, rhs: Opamp_Proto_AvailableComponents) -> Bool {
    if lhs.components != rhs.components {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_ComponentDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ComponentDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .standard(proto: "sub_component_map"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.metadata) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opamp_Proto_ComponentDetails>.self, value: &self.subComponentMap) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.metadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metadata, fieldNumber: 1)
    }
    if !self.subComponentMap.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opamp_Proto_ComponentDetails>.self, value: self.subComponentMap, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_ComponentDetails, rhs: Opamp_Proto_ComponentDetails) -> Bool {
    if lhs.metadata != rhs.metadata {return false}
    if lhs.subComponentMap != rhs.subComponentMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_ServerToAgent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerToAgent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instance_uid"),
    2: .standard(proto: "error_response"),
    3: .standard(proto: "remote_config"),
    4: .standard(proto: "connection_settings"),
    5: .standard(proto: "packages_available"),
    6: .same(proto: "flags"),
    7: .same(proto: "capabilities"),
    8: .standard(proto: "agent_identification"),
    9: .same(proto: "command"),
    10: .standard(proto: "custom_capabilities"),
    11: .standard(proto: "custom_message"),
  ]

  fileprivate class _StorageClass {
    var _instanceUid: Data = Data()
    var _errorResponse: Opamp_Proto_ServerErrorResponse? = nil
    var _remoteConfig: Opamp_Proto_AgentRemoteConfig? = nil
    var _connectionSettings: Opamp_Proto_ConnectionSettingsOffers? = nil
    var _packagesAvailable: Opamp_Proto_PackagesAvailable? = nil
    var _flags: UInt64 = 0
    var _capabilities: UInt64 = 0
    var _agentIdentification: Opamp_Proto_AgentIdentification? = nil
    var _command: Opamp_Proto_ServerToAgentCommand? = nil
    var _customCapabilities: Opamp_Proto_CustomCapabilities? = nil
    var _customMessage: Opamp_Proto_CustomMessage? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _instanceUid = source._instanceUid
      _errorResponse = source._errorResponse
      _remoteConfig = source._remoteConfig
      _connectionSettings = source._connectionSettings
      _packagesAvailable = source._packagesAvailable
      _flags = source._flags
      _capabilities = source._capabilities
      _agentIdentification = source._agentIdentification
      _command = source._command
      _customCapabilities = source._customCapabilities
      _customMessage = source._customMessage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._instanceUid) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._errorResponse) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._remoteConfig) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._connectionSettings) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._packagesAvailable) }()
        case 6: try { try decoder.decodeSingularUInt64Field(value: &_storage._flags) }()
        case 7: try { try decoder.decodeSingularUInt64Field(value: &_storage._capabilities) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._agentIdentification) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._command) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._customCapabilities) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._customMessage) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._instanceUid.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._instanceUid, fieldNumber: 1)
      }
      try { if let v = _storage._errorResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._remoteConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._connectionSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._packagesAvailable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._flags != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._flags, fieldNumber: 6)
      }
      if _storage._capabilities != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._capabilities, fieldNumber: 7)
      }
      try { if let v = _storage._agentIdentification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._command {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._customCapabilities {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._customMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_ServerToAgent, rhs: Opamp_Proto_ServerToAgent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._instanceUid != rhs_storage._instanceUid {return false}
        if _storage._errorResponse != rhs_storage._errorResponse {return false}
        if _storage._remoteConfig != rhs_storage._remoteConfig {return false}
        if _storage._connectionSettings != rhs_storage._connectionSettings {return false}
        if _storage._packagesAvailable != rhs_storage._packagesAvailable {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._capabilities != rhs_storage._capabilities {return false}
        if _storage._agentIdentification != rhs_storage._agentIdentification {return false}
        if _storage._command != rhs_storage._command {return false}
        if _storage._customCapabilities != rhs_storage._customCapabilities {return false}
        if _storage._customMessage != rhs_storage._customMessage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_OpAMPConnectionSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpAMPConnectionSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "destination_endpoint"),
    2: .same(proto: "headers"),
    3: .same(proto: "certificate"),
    4: .standard(proto: "heartbeat_interval_seconds"),
    5: .same(proto: "tls"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.destinationEndpoint) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._headers) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._certificate) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.heartbeatIntervalSeconds) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._tls) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.destinationEndpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationEndpoint, fieldNumber: 1)
    }
    try { if let v = self._headers {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._certificate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.heartbeatIntervalSeconds != 0 {
      try visitor.visitSingularUInt64Field(value: self.heartbeatIntervalSeconds, fieldNumber: 4)
    }
    try { if let v = self._tls {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_OpAMPConnectionSettings, rhs: Opamp_Proto_OpAMPConnectionSettings) -> Bool {
    if lhs.destinationEndpoint != rhs.destinationEndpoint {return false}
    if lhs._headers != rhs._headers {return false}
    if lhs._certificate != rhs._certificate {return false}
    if lhs.heartbeatIntervalSeconds != rhs.heartbeatIntervalSeconds {return false}
    if lhs._tls != rhs._tls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_TelemetryConnectionSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TelemetryConnectionSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "destination_endpoint"),
    2: .same(proto: "headers"),
    3: .same(proto: "certificate"),
    4: .same(proto: "tls"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.destinationEndpoint) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._headers) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._certificate) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._tls) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.destinationEndpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationEndpoint, fieldNumber: 1)
    }
    try { if let v = self._headers {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._certificate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._tls {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_TelemetryConnectionSettings, rhs: Opamp_Proto_TelemetryConnectionSettings) -> Bool {
    if lhs.destinationEndpoint != rhs.destinationEndpoint {return false}
    if lhs._headers != rhs._headers {return false}
    if lhs._certificate != rhs._certificate {return false}
    if lhs._tls != rhs._tls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_OtherConnectionSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OtherConnectionSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "destination_endpoint"),
    2: .same(proto: "headers"),
    3: .same(proto: "certificate"),
    4: .standard(proto: "other_settings"),
    5: .same(proto: "tls"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.destinationEndpoint) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._headers) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._certificate) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.otherSettings) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._tls) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.destinationEndpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationEndpoint, fieldNumber: 1)
    }
    try { if let v = self._headers {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._certificate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.otherSettings.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.otherSettings, fieldNumber: 4)
    }
    try { if let v = self._tls {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_OtherConnectionSettings, rhs: Opamp_Proto_OtherConnectionSettings) -> Bool {
    if lhs.destinationEndpoint != rhs.destinationEndpoint {return false}
    if lhs._headers != rhs._headers {return false}
    if lhs._certificate != rhs._certificate {return false}
    if lhs.otherSettings != rhs.otherSettings {return false}
    if lhs._tls != rhs._tls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_TLSConnectionSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TLSConnectionSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ca_pem_contents"),
    2: .standard(proto: "include_system_ca_certs_pool"),
    3: .standard(proto: "insecure_skip_verify"),
    4: .standard(proto: "min_version"),
    5: .standard(proto: "max_version"),
    6: .standard(proto: "cipher_suites"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.caPemContents) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.includeSystemCaCertsPool) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.insecureSkipVerify) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.minVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.maxVersion) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.cipherSuites) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.caPemContents.isEmpty {
      try visitor.visitSingularStringField(value: self.caPemContents, fieldNumber: 1)
    }
    if self.includeSystemCaCertsPool != false {
      try visitor.visitSingularBoolField(value: self.includeSystemCaCertsPool, fieldNumber: 2)
    }
    if self.insecureSkipVerify != false {
      try visitor.visitSingularBoolField(value: self.insecureSkipVerify, fieldNumber: 3)
    }
    if !self.minVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.minVersion, fieldNumber: 4)
    }
    if !self.maxVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.maxVersion, fieldNumber: 5)
    }
    if !self.cipherSuites.isEmpty {
      try visitor.visitRepeatedStringField(value: self.cipherSuites, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_TLSConnectionSettings, rhs: Opamp_Proto_TLSConnectionSettings) -> Bool {
    if lhs.caPemContents != rhs.caPemContents {return false}
    if lhs.includeSystemCaCertsPool != rhs.includeSystemCaCertsPool {return false}
    if lhs.insecureSkipVerify != rhs.insecureSkipVerify {return false}
    if lhs.minVersion != rhs.minVersion {return false}
    if lhs.maxVersion != rhs.maxVersion {return false}
    if lhs.cipherSuites != rhs.cipherSuites {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_Headers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Headers"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "headers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.headers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_Headers, rhs: Opamp_Proto_Headers) -> Bool {
    if lhs.headers != rhs.headers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_Header: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Header"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_Header, rhs: Opamp_Proto_Header) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_TLSCertificate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TLSCertificate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cert"),
    2: .standard(proto: "private_key"),
    3: .standard(proto: "ca_cert"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.cert) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.privateKey) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.caCert) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cert.isEmpty {
      try visitor.visitSingularBytesField(value: self.cert, fieldNumber: 1)
    }
    if !self.privateKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.privateKey, fieldNumber: 2)
    }
    if !self.caCert.isEmpty {
      try visitor.visitSingularBytesField(value: self.caCert, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_TLSCertificate, rhs: Opamp_Proto_TLSCertificate) -> Bool {
    if lhs.cert != rhs.cert {return false}
    if lhs.privateKey != rhs.privateKey {return false}
    if lhs.caCert != rhs.caCert {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_ConnectionSettingsOffers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectionSettingsOffers"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "opamp"),
    3: .standard(proto: "own_metrics"),
    4: .standard(proto: "own_traces"),
    5: .standard(proto: "own_logs"),
    6: .standard(proto: "other_connections"),
  ]

  fileprivate class _StorageClass {
    var _hash: Data = Data()
    var _opamp: Opamp_Proto_OpAMPConnectionSettings? = nil
    var _ownMetrics: Opamp_Proto_TelemetryConnectionSettings? = nil
    var _ownTraces: Opamp_Proto_TelemetryConnectionSettings? = nil
    var _ownLogs: Opamp_Proto_TelemetryConnectionSettings? = nil
    var _otherConnections: Dictionary<String,Opamp_Proto_OtherConnectionSettings> = [:]

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _hash = source._hash
      _opamp = source._opamp
      _ownMetrics = source._ownMetrics
      _ownTraces = source._ownTraces
      _ownLogs = source._ownLogs
      _otherConnections = source._otherConnections
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._hash) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._opamp) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._ownMetrics) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._ownTraces) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._ownLogs) }()
        case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opamp_Proto_OtherConnectionSettings>.self, value: &_storage._otherConnections) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._hash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._hash, fieldNumber: 1)
      }
      try { if let v = _storage._opamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._ownMetrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._ownTraces {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._ownLogs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._otherConnections.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opamp_Proto_OtherConnectionSettings>.self, value: _storage._otherConnections, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_ConnectionSettingsOffers, rhs: Opamp_Proto_ConnectionSettingsOffers) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._hash != rhs_storage._hash {return false}
        if _storage._opamp != rhs_storage._opamp {return false}
        if _storage._ownMetrics != rhs_storage._ownMetrics {return false}
        if _storage._ownTraces != rhs_storage._ownTraces {return false}
        if _storage._ownLogs != rhs_storage._ownLogs {return false}
        if _storage._otherConnections != rhs_storage._otherConnections {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_PackagesAvailable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PackagesAvailable"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "packages"),
    2: .standard(proto: "all_packages_hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opamp_Proto_PackageAvailable>.self, value: &self.packages) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.allPackagesHash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.packages.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opamp_Proto_PackageAvailable>.self, value: self.packages, fieldNumber: 1)
    }
    if !self.allPackagesHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.allPackagesHash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_PackagesAvailable, rhs: Opamp_Proto_PackagesAvailable) -> Bool {
    if lhs.packages != rhs.packages {return false}
    if lhs.allPackagesHash != rhs.allPackagesHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_PackageAvailable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PackageAvailable"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "version"),
    3: .same(proto: "file"),
    4: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._file) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .topLevel {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    try { if let v = self._file {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_PackageAvailable, rhs: Opamp_Proto_PackageAvailable) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.version != rhs.version {return false}
    if lhs._file != rhs._file {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_DownloadableFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DownloadableFile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "download_url"),
    2: .standard(proto: "content_hash"),
    3: .same(proto: "signature"),
    4: .same(proto: "headers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.downloadURL) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.contentHash) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._headers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.downloadURL.isEmpty {
      try visitor.visitSingularStringField(value: self.downloadURL, fieldNumber: 1)
    }
    if !self.contentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.contentHash, fieldNumber: 2)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 3)
    }
    try { if let v = self._headers {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_DownloadableFile, rhs: Opamp_Proto_DownloadableFile) -> Bool {
    if lhs.downloadURL != rhs.downloadURL {return false}
    if lhs.contentHash != rhs.contentHash {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs._headers != rhs._headers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_ServerErrorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerErrorResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "error_message"),
    3: .standard(proto: "retry_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      case 3: try {
        var v: Opamp_Proto_RetryInfo?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .retryInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .retryInfo(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    try { if case .retryInfo(let v)? = self.details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_ServerErrorResponse, rhs: Opamp_Proto_ServerErrorResponse) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_RetryInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RetryInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "retry_after_nanoseconds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.retryAfterNanoseconds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.retryAfterNanoseconds != 0 {
      try visitor.visitSingularUInt64Field(value: self.retryAfterNanoseconds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_RetryInfo, rhs: Opamp_Proto_RetryInfo) -> Bool {
    if lhs.retryAfterNanoseconds != rhs.retryAfterNanoseconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_ServerToAgentCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerToAgentCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .restart {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_ServerToAgentCommand, rhs: Opamp_Proto_ServerToAgentCommand) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_AgentDescription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AgentDescription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "identifying_attributes"),
    2: .standard(proto: "non_identifying_attributes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.identifyingAttributes) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.nonIdentifyingAttributes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifyingAttributes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.identifyingAttributes, fieldNumber: 1)
    }
    if !self.nonIdentifyingAttributes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nonIdentifyingAttributes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_AgentDescription, rhs: Opamp_Proto_AgentDescription) -> Bool {
    if lhs.identifyingAttributes != rhs.identifyingAttributes {return false}
    if lhs.nonIdentifyingAttributes != rhs.nonIdentifyingAttributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_ComponentHealth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ComponentHealth"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "healthy"),
    2: .standard(proto: "start_time_unix_nano"),
    3: .standard(proto: "last_error"),
    4: .same(proto: "status"),
    5: .standard(proto: "status_time_unix_nano"),
    6: .standard(proto: "component_health_map"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.healthy) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.lastError) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 5: try { try decoder.decodeSingularFixed64Field(value: &self.statusTimeUnixNano) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opamp_Proto_ComponentHealth>.self, value: &self.componentHealthMap) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.healthy != false {
      try visitor.visitSingularBoolField(value: self.healthy, fieldNumber: 1)
    }
    if self.startTimeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
    }
    if !self.lastError.isEmpty {
      try visitor.visitSingularStringField(value: self.lastError, fieldNumber: 3)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 4)
    }
    if self.statusTimeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.statusTimeUnixNano, fieldNumber: 5)
    }
    if !self.componentHealthMap.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opamp_Proto_ComponentHealth>.self, value: self.componentHealthMap, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_ComponentHealth, rhs: Opamp_Proto_ComponentHealth) -> Bool {
    if lhs.healthy != rhs.healthy {return false}
    if lhs.startTimeUnixNano != rhs.startTimeUnixNano {return false}
    if lhs.lastError != rhs.lastError {return false}
    if lhs.status != rhs.status {return false}
    if lhs.statusTimeUnixNano != rhs.statusTimeUnixNano {return false}
    if lhs.componentHealthMap != rhs.componentHealthMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_EffectiveConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EffectiveConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "config_map"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._configMap) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._configMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_EffectiveConfig, rhs: Opamp_Proto_EffectiveConfig) -> Bool {
    if lhs._configMap != rhs._configMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_RemoteConfigStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoteConfigStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_remote_config_hash"),
    2: .same(proto: "status"),
    3: .standard(proto: "error_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.lastRemoteConfigHash) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lastRemoteConfigHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.lastRemoteConfigHash, fieldNumber: 1)
    }
    if self.status != .unset {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_RemoteConfigStatus, rhs: Opamp_Proto_RemoteConfigStatus) -> Bool {
    if lhs.lastRemoteConfigHash != rhs.lastRemoteConfigHash {return false}
    if lhs.status != rhs.status {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_ConnectionSettingsStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectionSettingsStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_connection_settings_hash"),
    2: .same(proto: "status"),
    3: .standard(proto: "error_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.lastConnectionSettingsHash) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lastConnectionSettingsHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.lastConnectionSettingsHash, fieldNumber: 1)
    }
    if self.status != .unset {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_ConnectionSettingsStatus, rhs: Opamp_Proto_ConnectionSettingsStatus) -> Bool {
    if lhs.lastConnectionSettingsHash != rhs.lastConnectionSettingsHash {return false}
    if lhs.status != rhs.status {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_PackageStatuses: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PackageStatuses"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "packages"),
    2: .standard(proto: "server_provided_all_packages_hash"),
    3: .standard(proto: "error_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opamp_Proto_PackageStatus>.self, value: &self.packages) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.serverProvidedAllPackagesHash) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.packages.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opamp_Proto_PackageStatus>.self, value: self.packages, fieldNumber: 1)
    }
    if !self.serverProvidedAllPackagesHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.serverProvidedAllPackagesHash, fieldNumber: 2)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_PackageStatuses, rhs: Opamp_Proto_PackageStatuses) -> Bool {
    if lhs.packages != rhs.packages {return false}
    if lhs.serverProvidedAllPackagesHash != rhs.serverProvidedAllPackagesHash {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_PackageStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PackageStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "agent_has_version"),
    3: .standard(proto: "agent_has_hash"),
    4: .standard(proto: "server_offered_version"),
    5: .standard(proto: "server_offered_hash"),
    6: .same(proto: "status"),
    7: .standard(proto: "error_message"),
    8: .standard(proto: "download_details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.agentHasVersion) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.agentHasHash) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.serverOfferedVersion) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.serverOfferedHash) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._downloadDetails) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.agentHasVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.agentHasVersion, fieldNumber: 2)
    }
    if !self.agentHasHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.agentHasHash, fieldNumber: 3)
    }
    if !self.serverOfferedVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.serverOfferedVersion, fieldNumber: 4)
    }
    if !self.serverOfferedHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.serverOfferedHash, fieldNumber: 5)
    }
    if self.status != .installed {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 6)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 7)
    }
    try { if let v = self._downloadDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_PackageStatus, rhs: Opamp_Proto_PackageStatus) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.agentHasVersion != rhs.agentHasVersion {return false}
    if lhs.agentHasHash != rhs.agentHasHash {return false}
    if lhs.serverOfferedVersion != rhs.serverOfferedVersion {return false}
    if lhs.serverOfferedHash != rhs.serverOfferedHash {return false}
    if lhs.status != rhs.status {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs._downloadDetails != rhs._downloadDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_PackageDownloadDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PackageDownloadDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "download_percent"),
    2: .standard(proto: "download_bytes_per_second"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.downloadPercent) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.downloadBytesPerSecond) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.downloadPercent.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.downloadPercent, fieldNumber: 1)
    }
    if self.downloadBytesPerSecond.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.downloadBytesPerSecond, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_PackageDownloadDetails, rhs: Opamp_Proto_PackageDownloadDetails) -> Bool {
    if lhs.downloadPercent != rhs.downloadPercent {return false}
    if lhs.downloadBytesPerSecond != rhs.downloadBytesPerSecond {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_AgentIdentification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AgentIdentification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "new_instance_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.newInstanceUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.newInstanceUid.isEmpty {
      try visitor.visitSingularBytesField(value: self.newInstanceUid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_AgentIdentification, rhs: Opamp_Proto_AgentIdentification) -> Bool {
    if lhs.newInstanceUid != rhs.newInstanceUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_AgentRemoteConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AgentRemoteConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "config"),
    2: .standard(proto: "config_hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.configHash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.configHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.configHash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_AgentRemoteConfig, rhs: Opamp_Proto_AgentRemoteConfig) -> Bool {
    if lhs._config != rhs._config {return false}
    if lhs.configHash != rhs.configHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_AgentConfigMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AgentConfigMap"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "config_map"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opamp_Proto_AgentConfigFile>.self, value: &self.configMap) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.configMap.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opamp_Proto_AgentConfigFile>.self, value: self.configMap, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_AgentConfigMap, rhs: Opamp_Proto_AgentConfigMap) -> Bool {
    if lhs.configMap != rhs.configMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_AgentConfigFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AgentConfigFile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
    2: .standard(proto: "content_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.body) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.contentType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.body.isEmpty {
      try visitor.visitSingularBytesField(value: self.body, fieldNumber: 1)
    }
    if !self.contentType.isEmpty {
      try visitor.visitSingularStringField(value: self.contentType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_AgentConfigFile, rhs: Opamp_Proto_AgentConfigFile) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_CustomCapabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CustomCapabilities"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "capabilities"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.capabilities) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.capabilities.isEmpty {
      try visitor.visitRepeatedStringField(value: self.capabilities, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_CustomCapabilities, rhs: Opamp_Proto_CustomCapabilities) -> Bool {
    if lhs.capabilities != rhs.capabilities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opamp_Proto_CustomMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CustomMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "capability"),
    2: .same(proto: "type"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.capability) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.capability.isEmpty {
      try visitor.visitSingularStringField(value: self.capability, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opamp_Proto_CustomMessage, rhs: Opamp_Proto_CustomMessage) -> Bool {
    if lhs.capability != rhs.capability {return false}
    if lhs.type != rhs.type {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
